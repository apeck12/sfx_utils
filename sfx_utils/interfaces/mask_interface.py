import numpy as np
import h5py

class MaskInterface:
    
    def __init__(self):
        self.masks = dict()
        self.counter = 0
            
    def load_from_dials(self, input_file, geom_file):
        """
        Load a mask output by DIALS, assuming that each panel of the
        detector consists of 2x2 asics and a reshape from n_asics to
        n_panels is needed.
        
        Parameters
        ----------
        input_file : string
            .cxi file generated by Cheetah
        geom_file : string, optional
            path to a psana *-end.data file
        output_file : string, optional
            path for saving mask
            
        Returns
        -------
        mask : numpy.ndarray, 2d
            binary mask, with 0 indicating masked pixels
        """
        try:
            from sfx_utils.misc.cctbx import load_from_dials_asics
            from sfx_utils.interfaces.psana_interface import retrieve_pixel_index_map
            from sfx_utils.misc.detector import assemble_image_stack_batch
        except ImportError:
            print("Import Error, libtbx must be available")
            return
        
        mask = load_from_dials_asics(input_file)
        pixel_index_map = retrieve_pixel_index_map(geom_file)
        mask = assemble_image_stack_batch(mask, pixel_index_map)
        
        # optionally save mask
        if output_file:
            self.save_mask_to_h5(mask, output_file)

        self.masks[self.counter] = mask
        self.counter += 1
        
        return mask
            
    def load_from_h5(self, input_file, tag='data'):
        """
        Load a mask from an input hdf5 file. Here we expect masks
        to be assembled from a multi-panel array into a 2d image.

        Parameters
        ----------
        input_file : string
            hdf5 file containing mask
        tag : string
            key to extract from hdf5 file
            
        Returns
        -------
        mask : numpy.ndarray, 2d
            mask in shape of assembled detector
        """
        f = h5py.File(input_file, "r")
        mask = np.array(f[tag][tag][:]).copy()
        self.masks[self.counter] = mask
        f.close()

        self.counter += 1
        return mask
    
    def save_mask_to_h5(self, mask, output_file, tag='data'):
        """
        Save mask in h5 format.

        Parameters
        ----------
        mask : numpy.ndarray, 2d
            mask in shape of assembled detector
        tag : string
            key to extract from hdf5 file
        output_file : string
            path for saving mask
        """
        f = h5py.File(mask, "w")
        data = f.create_group(tag)
        data.create_dataset(tag, data=mask)
        f.close()
        
        print(f"Mask saved to {output_file}")
        return
    
    def generate_from_cxi_image(self, input_file, output_file=None):
        """
        Extract a random, single image from a multi-event .cxi file 
        generated by Cheetah and then apply thresholds on intensity
        values to generate a mask.
        
        Parameters
        ----------
        input_file : string
            .cxi file generated by Cheetah
        thresholds : tuple, length 2
            intensity value thresholds, (lower, upper)
        output_file : string, optional
            path for saving mask
            
        Returns
        -------
        mask : numpy.ndarray, 2d
            binary mask, with 0 indicating masked pixels
        """
        # retrieve a random image from .cxi file
        f = h5py.File(input_file, "r")
        data = np.array(f['entry_1']['data_1']['data'][:])
        idx = random.randint(0,data.shape[0])
        img = data[idx,:,:].copy()
        f.close()
        
        # apply thresholds 
        mask = np.ones(img.shape)
        mask[(img < thresholds[0]) | (img > thresholds[1])] = 0
        print(f"Mask generated from image {idx}")
        print(f"Number of dead pixels: {mask.size - np.count_nonzero(mask)}")
        
        # optionally save mask
        if output_file:
            self.save_mask_to_h5(mask, output_file)
        
        self.masks[self.counter] = mask
        self.counter += 1
        
        return mask
    
    def combine_masks(self, exclude=[], output_file=None):
        """
        Merge all stored masks.
        
        Parameters
        ----------
        exclude : list, optional
            if supplied, exclude these keys from merge
        output_file : string, optional
            path for saving mask
    
        Returns
        -------
        mask : numpy.ndarray, 2d
            merged mask, with 0 indicating masked pixels
        """
        merged_mask = np.ones_like(self.masks[list(self.masks.keys())[0]])
        for key in self.masks.keys():
            if key not in exclude:
                merged_mask *= self.masks[key]

        # optionally save mask
        if output_file:
            self.save_mask_to_h5(mask, output_file)

        return merged_mask
